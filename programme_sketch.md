λ⅋-исчисление (https://arxiv.org/abs/1907.03631) можно рассматривать как рудиментарный язык программирования, в котором реализуется concurrency при помощи join calculus.

Модель вычисления такая: имеется набор параллельно запущенных процессов и “питательный бульон”, в который процессы могут добавлять “молекулы” (значения, помеченные меткой-названием) или наоборот забирать из бульона такие значения по названию, причём молекулы в бульоне одноразовые.
“Программа“ это набор запускаемых параллельно вычислений p1 | p2 | p3, каждое из которых может внутри себя использовать как переменные x : T из контекста, так и переменные из “бульона”, меткой служит название переменной. Кроме того, вычисление из вычислений может добавлять значение в бульон командой (x̅ : A; expr) value. Это выполняется так: value выливается в бульон под меткой x (и процесс, который использует в своих вычислениях x, если он заблокировался из-за недоступности значения, немедленно может начинать вычислять), а потом продолжает вычислять expr.
Рудимертарность заключается в том, что в статье ничего не говорится о собственно типах данных, значениях и манипуляцях данными, подразумевается, что это добавляется отдельно. Термы в λ⅋ это не значения, а вычисления (computations), т.е. вычисляющие что-то и коммуницирующие в процессе вычисления друг с другом вычислительные процессы, это штуки неклонируемые, поэтому все переменные в λ⅋ можно использовать ровно по одному разу (подразумевается, по одному в каждой ветке вычисления, если вычисление может ветвиться).
Всроенная в λ⅋ минималистичная система типов лишь говорит, что для любых двух типов A и B имеются также тип A ⊸ B вычислений, принимающих аргументы типа A, и возвращающих (при условии завершения) результаты типа B, а также тип (A ⅋ B) “пары параллельно запущенных процессов типов A и B соответственно”. Ещё в λ⅋ имеется служебный тип ⊥ “завершившийся процесс”, но вообще-то можно прекрасно обойтись и без него ценой небольшого усложнения структуры термов*.
Если среди переменных есть переменная типа f : A ⊸ B, всякий процесс может её “вызвать” как функцию Важно, что имеющаяся в λ⅋ конструкция под названием ⅋-elimination позволяет расщипить “вызов процессом функции f”:
1) сохранить аргумент, с которым функция была вызвана в новую переменную “в бульоне”
2) “подвесить” процесс, вызвавший f в состояние ожидания результата (процесс развесится как только в бульон будет выброшено значение с нужным именем). Эквивалентно, “в бульоне висит continuation подвешенного процесса, который ждёт, пока ему дадут значение нужного типа и используют”.
Ну а дальше какие-то другие процессы что-то будут с этим значением вычислять и впоседствие возможно вернут заблокированный процесс к жизни.
Идея, которой я занимался всё это время, заключается в том, чтобы расширить λ⅋  “многоразовыми” переменными `f : A ⊸ B` “в бульоне”, играющими роль “исполняющих побочные эффекты запросов во вне, принимающими A и отвечающими B”, и рекурсивными (мульти-)обработчиками таких штуковин, как это сделано в языке программирования Frank (https://arxiv.org/pdf/1611.09259.pdf). Получается с одной стороны Frank с concurrency, а с другой стороны в терминах рекурсивных обработчиков образуются новые конструктори типов, в том числе возникают классические линейные типы “A ⊗ B” (имеются А и Б, нужно взять оба), “A ⊕ B” (имеются А и Б, нужно взять ровно один на выбор берущего), “A & B” (в ящике лежит одно из двух A или B), а также “!A” (фабрика по производству A) и ещё кое-что. Ах да, конечно же автоматически возникают также алгебарические типы данных и неограниченная рекурсия
Чтобы подход сработал, оказалось нужным сперва усложнить λ⅋, так чтобы он работал без типа ⊥, а потом добавить экспоненциальный тип “A ⋉ B”, введённый автором линейной логики в одном из своих недавних трактатов 2016 года. Этот тип соответствует франковскому “B with effect A”.
Очень интересная получается в итоге система. Важно, правда, понимать, что получается нечто непохожее на интуиционистские теории типов (которые тоже можно изготовить, взяв логическую систему и добавив к ней вычислителного мяса), т.к. оно недетерминистское и рекурсия вообще говоря не обязана завершаться. Однако, termination checker и eventual consistency checker для такой системы, вероятно, можно построить.
Есть и идеи каким образом эта штука могла бы масштабироваться до языка с зависимыми типами, и какую иметь при этом семантику (чуток подкрученный ∞-топос PSpec параметризованных спектров).
P. S. А квантовые вычисления в язык легко добавить позволив помещать “в бульон” QBit'ы (а лучше QNat'ы), причём при размещении фиксировать значение относительно одного базиса (посеттить спин относительно оси z в ±1/2 в зависимости от булевой переменной b), а считывать относительно другого базиса (относительно оси повёрнутой на 30 градуосов в бок от z, например).
